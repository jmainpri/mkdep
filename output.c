/** This is a -*-c-*- file **/
/*
 * Copyright (c) 1994 LAAS/CNRS 
 * Christophe Dousson - Thu Jun 16 1994
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include "mkdep.h"
#if HAVE_UNISTD_H
#   include <unistd.h>
#else
#   error("Not a POSIX system")
#endif

#include <errno.h>
#include <stdarg.h>


static const char* mkdep_header[] = 
{     "#--- DO NOT EDIT BELOW THIS LINE\n",
      "#--- These lines were automatically generated by `mkdep'\n"
};

/*
 * les cibles remises a jour par la commamde
 */

static deps * targets = NULL;

static FILE * olddeps = NULL;

static char * nametilde = NULL;
static char * namefile = NULL;

FILE * open_output_file(const char* name)
{
    FILE * fout;
    char line[4096];

    if (name == NULL) {
	printf ("%s%s\n", mkdep_header[0], mkdep_header[1]);
	return stdout;
    }

    if (access(name, R_OK) == 0) {
	/* le fichier existe deja, on cherche l'entete et */
	/* on le renomme avec un tilde (oh la bonne idee) */
	namefile = (char*) strdup(name);
	nametilde = (char*) malloc(strlen(name)+2);
	sprintf(nametilde, "%s~", name);
	if (rename(name, nametilde)) {
	    perror("mkdep"); exit(1);
	}
	olddeps = fopen(nametilde, "r");
	fout = fopen(name, "w");
	if (fout == NULL) {
	    perror("mkdep");
	    rename(nametilde, name);
	    free(namefile);
	    free(nametilde);
	    exit(1);
	}
	while (fgets(line, 4096, olddeps)) {
	    if (strcmp(line, mkdep_header[0]) == 0) {
		if (fgets(line, 4096, olddeps) == NULL) break; /* EOF*/
		if (strcmp(line, mkdep_header[1]) == 0) {
		    /* c'est bon, on a trouve le debut */
		    break;
		}
		/* c'est pas encore ca */
		fprintf(fout, "%s", mkdep_header[0]);
	    }
	    fprintf(fout, "%s", line);
	}
    } else {
	/* on cree le nouveau fichier */
	namefile = (char*) strdup(name);
	nametilde = NULL;
	fout = fopen(name, "w");
	if (fout == NULL) {
	    perror("mkdep"); 
	    free(namefile);
	    exit(1);
	}
    }
    fprintf (fout, "%s%s\n", mkdep_header[0], mkdep_header[1]);
    return fout;
}

void display_target(FILE * fout,
		    int compact,
		    char * file, 
		    const char * directory,
		    const char * library,
		    const char * suffix)
{	
    const char* vpath = find_file(file);
    { /* impression d'un message pour savoir ou on en est */
	char buffer[256];
	if (vpath == NULL) {
	    strcpy(buffer, file);
	} else {
	    sprintf(buffer, "%s/%s", vpath, file);
	}
	substitution_filtering(buffer);
	fprintf(stderr, "make dependencies for %s...\n", buffer);
    }
    { /* parsing des dependances */
	FILE * fin = run_preprocessor(file, vpath);
	reset_dependencies();
	parse_preprocessed_data(fin, vpath);
	pclose(fin);
    }
    { /* on tronque le suffixe .c, .cc...*/
	int pos;
	pos = strlen(file);
	while (file[pos] != '.' && file[pos] != '/' && pos >= 0) --pos;
	if (pos >= 0) {
	    if (file[pos] == '.') file[pos] = 0;
	    /* ... ainsi que le chemin d'acces */
	    while (file[pos] != '/' && pos >= 0) --pos;
	    if (pos >= 0) {
		file += pos + 1;
	    }
	}
    }
    { /* on calcule le nom de la ou des cible(s) */
	char target[256];
	if (library) {
	    sprintf(target,"%s(%s.o):", library, file);
	    targets = new_deps(target, targets);
	    display_dependencies(fout, compact, target);
	} 
	if (directory) {
	    sprintf(target,"%s/%s.%s:", directory, file,suffix);
	    targets = new_deps(target, targets);
	    display_dependencies(fout, compact, target);
	} 
	if ((library == NULL) && (directory == NULL)) {
	    sprintf(target, "%s.%s:", file, suffix);
	    targets = new_deps(target, targets);
	    display_dependencies(fout, compact, target);
	}
    }
}

void close_output_file(FILE * fout)
{
    if (olddeps != NULL) {
	/* on ajoute toutes les cibles non modifiees
	 * par mkdep (mkdep incremental) */
	int len;
	char line[4096];
	deps * current;
	while (fgets(line, 4096, olddeps)) {
	    if (line[0] != '\n') { /* ligne inutile */
		for (len = 0; len < 4096; ++len) {
		    if (line[len] == ':') { len++; break; }
		}
		current = targets;
		while (current != NULL) {
		    if (strncmp(line, current->name, len) == 0) {
			/* c'est une cible remise a jour */
			break;
		    }
		    current = current->next;
		}	
		/* on part du principe que les cibles sont separees
		   par une ligne vide, donc on traite par blocs */
		if (current == NULL) {
		    do {
			fprintf(fout, "%s",line);
			if (line[0] == '\n') break;
		    } while (fgets(line, 4096, olddeps));
		} else {
		    while (fgets(line, 4096, olddeps)) {
			if (line[0] == '\n') break;
		    }
		}
	    }
	}
    }
    if (fout != NULL) {
	fclose(fout);
    }
    unlink(nametilde);
    free(nametilde);
    free(namefile);
}


void interrupt_dependancies()
{
    fprintf(stderr,"mkdep: dependencies interrupted\n");
    if (nametilde != NULL) {
	/* on recupere l'ancien fichier */
	rename(nametilde, namefile);
	free(nametilde);
	free(namefile);
    } else {
	/* on efface le fichier en cours de creation */
	unlink(namefile);
	free(namefile);
    }
    exit(1);
}
